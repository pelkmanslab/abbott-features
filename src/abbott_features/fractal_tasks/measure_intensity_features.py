# Copyright 2022 (C) Friedrich Miescher Institute for Biomedical Research and
# University of Zurich
#
# Original authors:
# Ruth Hornbachner <ruth.hornbachner@uzh.ch>
#
# This file is part of Fractal and was originally developed by eXact lab S.r.l.
# <exact-lab.it> under contract with Liberali Lab from the Friedrich Miescher
# Institute for Biomedical Research and Pelkmans Lab from the University of
# Zurich.
"""Task to measure intensity features from OME-Zarr channels and

associated label image.
"""

import logging
from pathlib import Path

import numpy as np
import polars as pl
import spatial_image as si
from ngio import open_ome_zarr_container
from ngio.tables.tables_container import write_table
from ngio.tables.v1 import FeatureTableV1
from pydantic import validate_call

from abbott_features.features.constants import IntensityFeature
from abbott_features.features.intensity import get_intensity_features
from abbott_features.fractal_tasks.fractal_utils import (
    ChannelInputModel,
)

logger = logging.getLogger(__name__)


@validate_call
def measure_intensity_features(
    *,
    # Default arguments for fractal tasks:
    zarr_url: str,
    # Task-specific arguments:
    label_name: str,
    channels_to_include: list[ChannelInputModel] | None = None,
    channels_to_exclude: list[ChannelInputModel] | None = None,
    z_decay_correction: bool = False,  # TODO: implement
    t_decay_correction: bool = False,  # TODO: implement
    level: str = "0",
    ROI_table_name: str,
    output_table_name: str = "intensity_features",
) -> None:
    """Measure intensity features.

    This tasks loops over the ROIs in a given ROI table and measures intensity
    features within the label image. The features are saved as a .parquet table
    to be used in combination with polars.

    Args:
        zarr_url: Absolute path to the OME-Zarr image.
        label_name: Label image to be measured.
        channels_to_include: List of channels to include in the measurement.
        channels_to_exclude: List of channels to exclude from the
            measurement.
        z_decay_correction: If a z-decay correction model should be applied.
            Currently not implemented.
        t_decay_correction: If a t-decay correction model should be applied.
            Currently not implemented.
        level: Level of the OME-Zarr label to copy from. Valid choices are
            "0", "1", etc. (depending on which levels are available in the
            OME-Zarr label).
        ROI_table_name: Name of the ROI table over which the task loops to
            measure label features. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_table_name: Name of the output feature table.
        overwrite: Whether to overwrite an existing output table.
    """
    logging.info("Starting measure_intensity_features task")
    logging.info(f"{zarr_url=}")

    # TODO: allow user to select intensity features to measure
    features = tuple(IntensityFeature)

    # Open the OME-Zarr container
    ome_zarr_container = open_ome_zarr_container(zarr_url)

    # Validate that not both channels_to_include and channels_to_exclude are set
    if channels_to_include and channels_to_exclude:
        raise ValueError(
            "Only one of `channels_to_include` or `channels_to_exclude` " "can be set."
        )

    # Get channels to include/exclude
    channel_labels = ome_zarr_container.get_image(path=level).channel_labels
    if channels_to_include:
        channel_labels_to_include = [c.label for c in channels_to_include]
        channel_labels = [c for c in channel_labels if c in channel_labels_to_include]
    if channels_to_exclude:
        channel_labels_to_exclude = [c.label for c in channels_to_exclude]
        channel_labels = [
            c for c in channel_labels if c not in channel_labels_to_exclude
        ]

    # Get ROI table to loop over
    roi_table = ome_zarr_container.get_table(ROI_table_name)

    # Get the label image
    label_img = ome_zarr_container.get_label(label_name, path=level)
    axes_names = label_img.axes_mapper.on_disk_axes_names
    pixel_sizes = label_img.pixel_size.as_dict()

    # Get the images
    images = ome_zarr_container.get_image(path=level)

    # Check if the max label value exceeds uint16 range
    # Need to convert to uint16 as itk.LabelImageToShapeLabelMapFilter
    # does not support uint32
    label_img_numpy = label_img.get_array(mode="numpy")
    max_label_value = np.max(label_img_numpy)

    if max_label_value > 65535:  # uint16 max value
        raise ValueError(
            f"Label image contains values ({max_label_value}) that exceed the "
            f" maximum allowed value (65535) for processing with "
            "itk.LabelImageToShapeLabelMapFilter. "
        )
    logging.info(f"Start intensity feature measurement for {label_name=}")

    num_ROIs = len(roi_table.rois())
    channels_tables = []
    for channel_label in channel_labels:
        channel_idx = images.meta.get_channel_idx(label=channel_label)
        logging.info(
            f"Measuring intensity features for {channel_label=} in {label_name=}"
        )
        table_rois = []
        for i_ROI, roi in enumerate(roi_table.rois()):
            logging.info(f"Now processing ROI {i_ROI+1}/{num_ROIs}")

            image_numpy = (
                images.get_roi(roi, c=channel_idx, mode="numpy")
                .astype("uint16")
                .squeeze()
            )
            intensity_spatial_image = si.to_spatial_image(
                image_numpy,
                dims=axes_names,
                scale=pixel_sizes,
                name=channel_label,
            )

            label_numpy = label_img.get_roi(roi).astype("uint16")
            label_spatial_image = si.to_spatial_image(
                label_numpy,
                dims=axes_names,
                scale=pixel_sizes,
                name=label_name,
            )
            table_roi = get_intensity_features(
                label_image=label_spatial_image,
                intensity_image=intensity_spatial_image,
                ROI_id=str(roi.name),
                features=features,
            )

            table_rois.append(table_roi)

        channel_table = pl.concat(table_rois, how="align")
        channels_tables.append(channel_table)

    logging.info(f"Finished intensity feature measurement for {label_name=}")

    # Concatenate all channel tables
    table_out = pl.concat(channels_tables, how="align")

    # Save the output table
    # TODO: enforce label_name ("object") in table name?
    store = Path(f"{zarr_url}/tables/{output_table_name}")

    feature_table = FeatureTableV1(table_out, reference_label="label")
    write_table(store=store, table=feature_table, backend="experimental_parquet_v1")


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(task_function=measure_intensity_features)
