# Copyright 2022 (C) Friedrich Miescher Institute for Biomedical Research and
# University of Zurich
#
# Original authors:
# Ruth Hornbachner <ruth.hornbachner@uzh.ch>
#
# This file is part of Fractal and was originally developed by eXact lab S.r.l.
# <exact-lab.it> under contract with Liberali Lab from the Friedrich Miescher
# Institute for Biomedical Research and Pelkmans Lab from the University of
# Zurich.

"""Task to measure colocalization features from OME-Zarr channels and

associated label image.
"""

import logging
from pathlib import Path

import numpy as np
import polars as pl
import spatial_image as si
from ngio import open_ome_zarr_container
from ngio.tables.tables_container import write_table
from ngio.tables.v1 import FeatureTableV1
from pydantic import validate_call

from abbott_features.features.colocalization import (
    get_colocalization_features,
)
from abbott_features.features.constants import DefaultColocalizationFeature
from abbott_features.fractal_tasks.fractal_utils import ChannelPairInputModel

logger = logging.getLogger(__name__)


@validate_call
def measure_colocalization_features(
    *,
    # Default arguments for fractal tasks:
    zarr_url: str,
    # Task-specific arguments:
    label_name: str,
    channel_pairs: list[ChannelPairInputModel],
    z_decay_correction: bool = False,  # TODO: implement
    t_decay_correction: bool = False,  # TODO: implement
    level: str = "0",
    ROI_table_name: str,
    output_table_name: str = "colocalization_features",
) -> None:
    """Measure colocalization features.

    This tasks loops over the ROIs in a given ROI table and measures colocalization
    features within the label image. The features are saved as a .parquet table
    to be used in combination with polars.

    Args:
        zarr_url: Absolute path to the OME-Zarr image.
        label_name: Label image to be measured.
        channel_pairs: List of channel pairs to measure colocalization features.
        level: Level of the OME-Zarr label to copy from. Valid choices are
            "0", "1", etc. (depending on which levels are available in the
            OME-Zarr label).
        z_decay_correction: TODO
        t_decay_correction: TODO
        ROI_table_name: Name of the ROI table over which the task loops to
            measure label features. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_table_name: Name of output feature table.
        overwrite: Whether to overwrite an existing output table.
    """
    logging.info("Starting measure_colocalization_features task")
    logging.info(f"{zarr_url=}")

    # TODO: allow user to select features to measure
    features = tuple(DefaultColocalizationFeature)

    # Open the OME-Zarr container
    ome_zarr_container = open_ome_zarr_container(zarr_url)

    # Get ROI table to loop over
    roi_table = ome_zarr_container.get_table(ROI_table_name)

    # Get the label image
    label_img = ome_zarr_container.get_label(label_name, path=level)
    axes_names = label_img.axes_mapper.on_disk_axes_names
    pixel_sizes = label_img.pixel_size.as_dict()

    # Get the images
    images = ome_zarr_container.get_image(path=level)

    # Check if the max label value exceeds uint16 range
    # Need to convert to uint16 as itk.LabelImageToShapeLabelMapFilter
    # does not support uint32
    label_img_numpy = label_img.get_array(mode="numpy")
    max_label_value = np.max(label_img_numpy)

    if max_label_value > 65535:  # uint16 max value
        raise ValueError(
            f"Label image contains values ({max_label_value}) that exceed the "
            f" maximum allowed value (65535) for processing with "
            "itk.LabelImageToShapeLabelMapFilter. "
        )
    logging.info(f"Start intensity feature measurement for {label_name=}")

    num_ROIs = len(roi_table.rois())
    colocalization_tables = []
    for channel_pair in channel_pairs:
        # Get the channel pair
        channel_0_lbl = channel_pair.channel0.label
        channel_1_lbl = channel_pair.channel1.label

        channel_0_idx = images.meta.get_channel_idx(label=channel_0_lbl)
        channel_1_idx = images.meta.get_channel_idx(label=channel_1_lbl)
        logging.info(
            f"Measuring colocalisation features for {channel_0_lbl=} and "
            f"{channel_1_lbl=} in {label_name=}"
        )
        table_rois = []
        for i_ROI, roi in enumerate(roi_table.rois()):
            logging.info(f"Now processing ROI {i_ROI+1}/{num_ROIs}")

            # Get channel 0
            image_0_numpy = (
                images.get_roi(roi, c=channel_0_idx, mode="numpy")
                .astype("uint16")
                .squeeze()
            )
            channel_0_spatial_inage = si.to_spatial_image(
                image_0_numpy,
                dims=axes_names,
                scale=pixel_sizes,
                name=channel_0_lbl,
            )

            # And channel 1
            image_1_numpy = (
                images.get_roi(roi, c=channel_1_idx, mode="numpy")
                .astype("uint16")
                .squeeze()
            )
            channel_1_spatial_image = si.to_spatial_image(
                image_1_numpy,
                dims=axes_names,
                scale=pixel_sizes,
                name=channel_1_lbl,
            )

            # Get the label image
            label_numpy = label_img.get_roi(roi).astype("uint16")
            label_spatial_image = si.to_spatial_image(
                label_numpy,
                dims=axes_names,
                scale=pixel_sizes,
                name=label_name,
            )

            # Get the colocalization features
            table_roi = get_colocalization_features(
                label_image=label_spatial_image,
                channel0=channel_0_spatial_inage,
                channel1=channel_1_spatial_image,
                ROI_id=str(roi.name),
                features=features,
            )

            table_rois.append(table_roi)

        colocalization_table = pl.concat(table_rois, how="align")
        colocalization_tables.append(colocalization_table)

    logging.info(f"Finished colocalisation feature measurement for {label_name=}")

    # Concatenate all colocalization tables
    table_out = pl.concat(colocalization_tables, how="align")

    # Save the output table
    # TODO: enforce label_name ("object") in table name?
    store = Path(f"{zarr_url}/tables/{output_table_name}")

    feature_table = FeatureTableV1(table_out, reference_label="label")
    write_table(store=store, table=feature_table, backend="experimental_parquet_v1")


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(task_function=measure_colocalization_features)
