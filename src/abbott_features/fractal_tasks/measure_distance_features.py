# Copyright 2022 (C) Friedrich Miescher Institute for Biomedical Research and
# University of Zurich
#
# Original authors:
# Ruth Hornbachner <ruth.hornbachner@uzh.ch>
#
# This file is part of Fractal and was originally developed by eXact lab S.r.l.
# <exact-lab.it> under contract with Liberali Lab from the Friedrich Miescher
# Institute for Biomedical Research and Pelkmans Lab from the University of
# Zurich.

"""Task to measure distance features from OME-Zarr channels and associated

label image.
"""

import logging
from pathlib import Path

import numpy as np
import polars as pl
from ngio import open_ome_zarr_container
from ngio.tables.tables_container import write_table
from ngio.tables.v1 import FeatureTableV1
from pydantic import validate_call

from abbott_features.features.constants import (
    DefaultDistanceFeature,
    DefaultDistanceFunction,
)
from abbott_features.features.distance import get_distance_features

logger = logging.getLogger(__name__)


@validate_call
def measure_distance_features(
    *,
    # Default arguments for fractal tasks:
    zarr_url: str,
    # Task-specific arguments:
    label_name: str,
    label_name_to: str,
    z_decay_correction: bool = False,  # TODO: implement
    t_decay_correction: bool = False,  # TODO: implement
    level: str = "0",
    ROI_table_name: str,
    output_table_name: str = "distance_features",
) -> None:
    """Measure distance features.

    This tasks loops over the ROIs in a given ROI table and measures distance
    features within the label images. The features are saved as a .parquet table
    to be used in combination with polars.

    Args:
        zarr_url: Absolute path to the OME-Zarr image.
        label_name: Label image to be measured.
        label_name_to: Name of the label image to measure distance to e.g.
            "embryo" or "organoid".
        z_decay_correction: If a z-decay correction model should be applied.
            Currently not implemented.
        t_decay_correction: If a t-decay correction model should be applied.
            Currently not implemented.
        level: Level of the OME-Zarr label to copy from. Valid choices are
            "0", "1", etc. (depending on which levels are available in the
            OME-Zarr label).
        ROI_table_name: Name of the ROI table over which the task loops to
            measure label features. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_table_name: Name of the output feature table.
        overwrite: Whether to overwrite an existing output table.
    """
    logging.info("Starting measure_distance_features task")
    logging.info(f"{zarr_url=}")

    # TODO: allow user to select features to measure
    features = tuple(DefaultDistanceFeature)
    distance_transforms = tuple(DefaultDistanceFunction)

    # Open the OME-Zarr container
    ome_zarr_container = open_ome_zarr_container(zarr_url)

    # Get ROI table to loop over
    roi_table = ome_zarr_container.get_table(ROI_table_name)

    # Get the label image
    label_img = ome_zarr_container.get_label(label_name, path=level)

    # Get the label image to measure distance to
    label_img_to = ome_zarr_container.get_label(label_name_to, path=level)

    # Check if the max label value exceeds uint16 range
    # Need to convert to uint16 as itk.LabelImageToShapeLabelMapFilter
    # does not support uint32
    label_img_numpy = label_img.get_array(mode="numpy")
    max_label_value = np.max(label_img_numpy)

    if max_label_value > 65535:  # uint16 max value
        raise ValueError(
            f"Label image contains values ({max_label_value}) that exceed the "
            f" maximum allowed value (65535) for processing with "
            "itk.LabelImageToShapeLabelMapFilter. "
        )

    logging.info(f"Start distance feature measurement for {label_name=}")

    num_ROIs = len(roi_table.rois())

    logging.info(f"Measuring distance features for {label_name=} in {label_name_to=}")
    table_rois = []
    for i_ROI, roi in enumerate(roi_table.rois()):
        logging.info(f"Now processing ROI {i_ROI+1}/{num_ROIs}")

        # Get the distance features
        table_roi = get_distance_features(
            label_image=label_img,
            label_image_to=label_img_to,
            roi=roi,
            distance_transforms=distance_transforms,
            features=features,
        )

        table_rois.append(table_roi)

    logging.info(f"Finished distance feature measurement for {label_name=}")

    # Concatenate all distance tables
    table_out = pl.concat(table_rois, how="align")

    # Save the output table
    store = Path(f"{zarr_url}/tables/{output_table_name}")

    feature_table = FeatureTableV1(table_out, reference_label="label")
    write_table(store=store, table=feature_table, backend="experimental_parquet_v1")


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(task_function=measure_distance_features)
