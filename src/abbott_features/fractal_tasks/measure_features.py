# Copyright 2022 (C) Friedrich Miescher Institute for Biomedical Research and
# University of Zurich
#
# Original authors:
# Ruth Hornbachner <ruth.hornbachner@uzh.ch>
#
# This file is part of Fractal and was originally developed by eXact lab S.r.l.
# <exact-lab.it> under contract with Liberali Lab from the Friedrich Miescher
# Institute for Biomedical Research and Pelkmans Lab from the University of
# Zurich.

"""Task to measure features from 3D label images."""

import logging
from pathlib import Path
from typing import Optional

import numpy as np
import polars as pl
from ngio import open_ome_zarr_container
from ngio.tables.v1 import FeatureTableV1
from pydantic import validate_call

from abbott_features.features.colocalization import (
    get_colocalization_features,
)
from abbott_features.features.distance import (
    get_distance_features,
)
from abbott_features.features.intensity import (
    get_intensity_features,
)
from abbott_features.features.label import (
    get_label_features,
)
from abbott_features.features.neighborhood.neighborhood import (
    get_neighborhood_features,
)
from abbott_features.fractal_tasks.fractal_utils import (
    ColocalizationFeaturesInputModel,
    DistanceFeaturesInputModel,
    IntensityFeaturesInputModel,
    NeighborhoodFeaturesInputModel,
    get_zarrurl_from_image_label,
)

logger = logging.getLogger(__name__)


@validate_call
def measure_features(
    *,
    # Default arguments for fractal tasks:
    zarr_url: str,
    # Task-specific arguments:
    label_name: str,
    reference_acquisition: Optional[int] = None,
    level: str = "0",
    ROI_table_name: str,
    measure_label_features: bool = False,
    measure_intensity_features: Optional[IntensityFeaturesInputModel] = None,
    measure_distance_features: Optional[DistanceFeaturesInputModel] = None,
    measure_colocalization_features: Optional[ColocalizationFeaturesInputModel] = None,
    measure_neighborhood_features: Optional[NeighborhoodFeaturesInputModel] = None,
    z_decay_correction: Optional[str] = None,  # TODO: implement
    t_decay_correction: Optional[str] = None,  # TODO: implement
    output_table_name: Optional[str] = None,
    overwrite: bool = True,
) -> None:
    """Measure features.

    This tasks loops over the ROIs in a given ROI table and measures colocalization
    features within the label image. The features are saved as a .parquet table
    to be used in combination with polars.

    Args:
        zarr_url: Absolute path to the OME-Zarr image.
        label_name: Label image to be measured.
        reference_acquisition: The reference acquisition that contains the label
            image and table to perform the measurement on. If not provided, the
            task assumes that each acquisition has its own label image and table.
        level: Level of the OME-Zarr label to copy from. Valid choices are
            "0", "1", etc. (depending on which levels are available in the
            OME-Zarr label).
        measure_label_features: Whether to measure label features.
        measure_intensity_features: From which channels intensity features should be
            measured. If not provided, the task will not measure any intensity
            features.
        measure_distance_features: If `label_name_to` is provided, the task will measure
            distance features of `label_name` relative to `label_name_to`
            e.g. `embryo` or `organoid` segmentation.
        measure_colocalization_features: If `channel_pair` is set, the task will
            measure colocalization features per channel pair. E.g. colocalization
            between `channel_0` and `channel_1`.
        measure_neighborhood_features: If `measure` is set to True, neighborhood
            features will be measured. If neighborhood is measured in e.g. `embryo`
            or `organoid` segmentation provide the `label_img_mask`.
        z_decay_correction: TODO
        t_decay_correction: TODO
        ROI_table_name: Name of the ROI table over which the task loops to
            measure label features. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_table_name: Name of the output feature table.
        overwrite: Whether to overwrite an existing output feature table.
    """
    logging.info("Starting measure_features task")
    logging.info(f"{zarr_url=}")

    # Get ref_zarr_url of reference acquisition
    # where the label image and table is stored if provided
    # otherwise assumes each acquisition has its own label image and table
    if reference_acquisition is not None:
        well_url = Path(zarr_url).parent
        ref_zarr_url = (well_url / str(reference_acquisition)).as_posix()
    else:
        ref_zarr_url = zarr_url

    # Open the OME-Zarr container
    ome_zarr_container = open_ome_zarr_container(zarr_url)

    # Get OME-Zarr container of reference acquisition
    ome_zarr_container_ref = open_ome_zarr_container(ref_zarr_url)

    # Get ROI table to loop over
    roi_table = ome_zarr_container_ref.get_table(ROI_table_name)

    # Get the label image
    label_img = ome_zarr_container_ref.get_label(label_name, path=level)

    # Check if the max label value exceeds uint16 range
    # Need to convert to uint16 as itk.LabelImageToShapeLabelMapFilter
    # does not support uint32
    label_img_numpy = label_img.get_array(mode="numpy")
    max_label_value = np.max(label_img_numpy)

    if max_label_value > 65535:  # uint16 max value
        raise ValueError(
            f"Label image contains values ({max_label_value}) that exceed the "
            f" maximum allowed value (65535) for processing with "
            "itk.LabelImageToShapeLabelMapFilter. "
        )

    # Get the images
    images = ome_zarr_container.get_image(path=level)

    # Get channels to include/exclude
    if measure_intensity_features is not None:
        channel_labels = ome_zarr_container.get_image(path=level).channel_labels
        if measure_intensity_features.channels_to_include is not None:
            channel_labels_to_include = [
                c.label for c in measure_intensity_features.channels_to_include
            ]
            channel_labels = [
                c for c in channel_labels if c in channel_labels_to_include
            ]
        if measure_intensity_features.channels_to_exclude is not None:
            channel_labels_to_exclude = [
                c.label for c in measure_intensity_features.channels_to_exclude
            ]
            channel_labels = [
                c for c in channel_labels if c not in channel_labels_to_exclude
            ]

    logging.info(f"Start feature measurement for {label_name=} and {zarr_url=}")

    num_ROIs = len(roi_table.rois())
    tables_list = []
    for i_ROI, roi in enumerate(roi_table.rois()):
        tables_roi_list = []
        logging.info(f"Now processing ROI {i_ROI+1}/{num_ROIs}")

        # Measure features per ROI
        if measure_label_features:
            if zarr_url == ref_zarr_url:
                logging.info(f"Measure label features for {label_name=} in {zarr_url=}")
                label_roi_table = get_label_features(
                    label_image=label_img,
                    roi=roi,
                )
                tables_roi_list.append(label_roi_table)

        if measure_intensity_features is not None:
            if channel_labels:
                channel_roi_table_list = []
                for channel_label in channel_labels:
                    channel_roi_table = get_intensity_features(
                        label_image=label_img,
                        images=images,
                        channel_label=channel_label,
                        roi=roi,
                    )

                    channel_roi_table_list.append(channel_roi_table)
                intensity_roi_table = pl.concat(channel_roi_table_list, how="align")
                tables_roi_list.append(intensity_roi_table)

        if measure_distance_features is not None:
            if zarr_url == ref_zarr_url:
                logging.info(
                    f"Measure distance features for {label_name=} in {zarr_url=}"
                )
                label_img_to = ome_zarr_container_ref.get_label(
                    measure_distance_features.label_name_to, path=level
                )
                distance_roi_table = get_distance_features(
                    label_image=label_img, label_image_to=label_img_to, roi=roi
                )
                tables_roi_list.append(distance_roi_table)

        if measure_colocalization_features is not None:
            if zarr_url == ref_zarr_url:
                logging.info(
                    f"Measure colocalization features for {label_name=} in {zarr_url=}"
                )
                colocalization_roi_table_list = []
                for channel_pair in measure_colocalization_features.channel_pair:
                    channel_0_lbl = channel_pair.channel0.label
                    channel_1_lbl = channel_pair.channel1.label

                    channel_0_zarr_url = get_zarrurl_from_image_label(
                        well_url=well_url,
                        channel_label=channel_0_lbl,
                        level=level,
                    )
                    channel_0 = {
                        "channel_label": channel_0_lbl,
                        "channel_zarr_url": channel_0_zarr_url,
                    }

                    channel_1_zarr_url = get_zarrurl_from_image_label(
                        well_url=well_url,
                        channel_label=channel_1_lbl,
                        level=level,
                    )
                    channel_1 = {
                        "channel_label": channel_1_lbl,
                        "channel_zarr_url": channel_1_zarr_url,
                    }

                    colocalization_roi_table = get_colocalization_features(
                        label_image=label_img,
                        channel0=channel_0,
                        channel1=channel_1,
                        level=level,
                        roi=roi,
                    )
                    colocalization_roi_table_list.append(colocalization_roi_table)

                colocalization_roi_table = pl.concat(
                    colocalization_roi_table_list, how="align"
                )
                tables_roi_list.append(colocalization_roi_table)

        if measure_neighborhood_features.measure:
            if zarr_url == ref_zarr_url:
                logging.info(
                    f"Measure neighborhood features for {label_name=} in {zarr_url=}"
                )
                label_img_mask = ome_zarr_container_ref.get_label(
                    measure_neighborhood_features.label_img_mask, path=level
                )
                neighborhood_table = get_neighborhood_features(
                    label_image=label_img,
                    label_img_mask=label_img_mask,
                    roi=roi,
                )
                tables_roi_list.append(neighborhood_table)

        if tables_roi_list:
            tables_roi = pl.concat(tables_roi_list, how="align")
            tables_list.append(tables_roi)

    logging.info(f"Finished feature measurement for {label_name=} and {zarr_url=}")

    if tables_list:
        table_out = pl.concat(tables_list)

        # Save the output table
        if output_table_name is None:
            output_table_name = label_name

        feature_table = FeatureTableV1(table_out, reference_label="label")
        ome_zarr_container.add_table(
            name=output_table_name,
            table=feature_table,
            backend="experimental_parquet_v1",
            overwrite=overwrite,
        )

        logging.info("Finished saving table")


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(task_function=measure_features)
